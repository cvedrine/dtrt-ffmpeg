#! /usr/bin/env zsh

# TODO: thumbnails:
# * 20, 50 et 80 et utiliser l'API
# TODO: overview:
# * registrer overview.jpg avec l'API
# TODO: the current output_template is insecure
# (as a backtrick in it or in the file name can have remote code execution )
# TODO: scale is a mock
# don't really use arguements to decide everything
# TODO: fallback when GPU fail (cuvid and nvenc)
# TODO: -codec:a aac could be replaced by libfdk_aac ???
# TODO: add -d arg for output dir

# steal encoding examples from pod and psm

. dtrt-ffmpeg.zsh

alias l='print -l'

scaling_args_commons=(
    # want to test ?
    # -t 5
    -codec:a aac
    -ar 48000
    -strict -2 -ac 2
    -movflags faststart
    -profile:v high -pix_fmt yuv420p -preset faster
    -y )

reads () { for it { typeset -g $it; read $it; } }
evalp () { eval "$(print "$@")" }
status_as_string () { print -P "%(?.true.false)" }
status_as_flag   () { evalp -P "$1=%(?.true.false)" }

# use_nvidia_gpu plutot que use_cuvid
if {$use_cuvid} {
    is_h264_video && encoder+=( -hwaccel cuvid -c:v h264_cuvid )
    scaling_args () { encoder+=(
        $scaling_args_commons
        -vcodec h264_nvenc -vf scale_nnp=$width\x$height ) }
} else {
    scaling_args () {
        encoder+=(
            $scaling_args_commons
            -codec:v libx264 -vf scale=$width\x$height ) } }

video_info_get () { ffprobe \
    -v error -select_streams v \
    -show_entries stream=${2?list of infos to print separated by a coma} \
    -of default=noprint_wrappers=1:nokey=1 ${1?path of the video}
}

input () {
    setopt localoptions nowarncreateglobal
    typeset -g input_{width,height,video_codec} input=${1?path to the input video}
    video_info_get $input width,height,codec_name |
        reads input_{width,height,video_codec_name}
    test h264 = "$( video_codec_name ${1?path of the media to test} )"
    ${(%):-'use_cuvid=%(?.true.false)'}

    encoder+=( -i $input )


}

output () {
# setopt localoptions nowarncreateglobal
output_template=${1?template for the path of output file}
}

is_downscale () (( input_height > height ))

is_upscale () {
local tolerance=${1?a tolerance in decimal notation (aka .1 for 10%)}
(( ( input_height > height ) &&
   ( input_height - height ) < ( input_height * tolerance )))
}

scale () {
typeset -g width height output

for it ($available_sizes) {
    width=${it:r} height=${it:e}
    output="$( eval echo $output_template )"

    is_downscale  ||
    is_upscale .1 ||
    continue

    # TODO:
    # this should be a pre-process parameter or something
    # ... or this should be the output :)
    echo $height $output >> downscaled

    [[ -f $output && $output -nt $input ]] || {
        need_to_encode=true
        scaling_args
        encoder+=( $output )
    }
}
}

#template=${1?the template for output file}
:        ${1?at least one video to encode}

_rep () { cat <<-.
	# need_to_encode $need_to_encode
	# use_cuvid $use_cuvid
	# use_slurm $use_slurm
	$encoder
	.
}

for doit {
need_to_encode=false
input $doit
# ffprobe_dump_in out/info $input
output '${input:t:r}_${width}x${height}.mp4'
    scale always 240 downscale upscale_almost '10%'
    _rep > command
    $need_to_encode && {
        $encoder }
}
