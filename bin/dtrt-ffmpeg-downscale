#! /usr/bin/env zsh

# TODO: the current output_template is insecure
# (as a backtrick in it or in the file name can have remote code execution )
# TODO: scale is a mock
# don't really use arguements to decide everything
# TODO: fallback when GPU fail (cuvid and nvenc)

# stolen from the pod code
# psm should be a good cookbook too

# ENCODE_MP4_CMD = 'ENCODE_MP4_CMD', "%(ffmpeg)s -i %(src)s -codec:v ibx264 -profile:v high -pix_fmt yuv420p -preset faster -b:v %(bv)s -maxrate %(bv)s -bufsize %(bufsize)s -vf scale=%(scale)s -force_key_frames \"expr:gte(t,n_forced*1)\" -deinterlace -threads 0 -codec:a aac -strict -2 -ar %(ar)s -ac 2 -b:a %(ba)s -movflags faststart -y %(out)s")
# ENCODE_WEBM_CMD =  'ENCODE_WEBM_CMD',
#                           "%(ffmpeg)s -i %(src)s -codec:v libvpx -quality realtime -cpu-used 3 -b:v %(bv)s -maxrate %(bv)s -bufsize %(bufsize)s -qmin 10 -qmax 42 -threads 4 -codec:a libvorbis -y %(out)s")
# ENCODE_MP3_CMD =  'ENCODE_MP3_CMD',
#                          "%(ffmpeg)s -i %(src)s -vn -ar %(ar)s -ab %(ab)s -f mp3 -threads 0 -y %(out)s")
# ENCODE_WAV_CMD =  'ENCODE_WAV_CMD',
#                          "%(ffmpeg)s -i %(src)s -ar %(ar)s -ab %(ab)s -f wav -threads 0 -y %(out)s")


. dtrt-ffmpeg.zsh

alias l='print -l'

scaling_args_commons=(
# want to test ?
# -t 5
-y
-codec:a aac -strict -2 -ac 2 -movflags faststart
-profile:v high -pix_fmt yuv420p -preset faster )

if {$use_cuvid} {
scaling_args () { encoder+=(
    $scaling_args_commons
    -vcodec h264_nvenc -vf scale_nnp=$width\x$height ) }
encoder+=( -hwaccel cuvid -c:v h264_cuvid )
} else {
scaling_args () {
    encoder+=(
        $scaling_args_commons
        -codec:v libx264 -vf scale=$width\x$height ) }
}

reads () { for it { typeset -g $it; read $it; } }

video_size () {
ffprobe \
    -v error -select_streams v -show_entries stream=width,height \
    -of default=noprint_wrappers=1:nokey=1 ${1?path of the video}
}

# runner/slurm
# pu/cuvid

input () {
# setopt localoptions nowarncreateglobal
typeset -g input_{width,height} input=${1?path to the input video}
video_size $input |
    reads input_{width,height}
encoder+=( -i $input )
}

output () {
# setopt localoptions nowarncreateglobal
output_template=${1?template for the path of output file}
}

is_downscale () (( input_height > height ))

is_upscale () {
local tolerance=${1?a tolerance in decimal notation (aka .1 for 10%)}
(( ( input_height > height ) &&
   ( input_height - height ) < ( input_height * tolerance )))
}

scale () {
typeset -g width height output

for it ($available_sizes) {
    width=${it:r} height=${it:e}
    output="$( eval echo $output_template )"

    is_downscale  ||
    is_upscale .1 ||
    continue

    # this should be a pre-process parameter or something
    # ... or this should be the output :)
    echo $height $output >> downscaled

    [[ -f $output && $output -nt $input ]] || {
        need_to_encode=true
        scaling_args
        encoder+=( $output )
    }
}
}

#template=${1?the template for output file}
:        ${1?at least one video to encode}

_rep () { cat <<-.
	# need_to_encode $need_to_encode
	# use_cuvid $use_cuvid
	# use_slurm $use_slurm
	$encoder
	.
}

for doit {
need_to_encode=false
input $doit
# ffprobe_dump_in out/info $input
output '${input:t:r}_${width}x${height}.mp4'
    scale always 240 downscale upscale_almost '10%'
    _rep > command
    $need_to_encode && {
        l $encoder
        $encoder }
}
