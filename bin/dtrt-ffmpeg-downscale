#! /usr/bin/env zsh
# TODO: the current output_template is insecure
# (as a backtrick in it or in the file name can have remote code execution )
# TODO: scale is a mock
# don't really use arguements to decide everything
# TODO: fallback when GPU fail (cuvid and nvenc)

. dtrt-ffmpeg.zsh

scaling_args () { encoder+=( -vf scale=$width\x$height ) }

$use_cuvid && {
    scaling_args () { encoder+=( -vf scale_nnp=$width\x$height ) }
    encoder=( ffmpeg -hwaccel cuvid -c:v h264_cuvid )
}

reads () { for it { typeset -g $it; read $it; } }

video_size () {
    ffprobe \
        -v error -select_streams v -show_entries stream=width,height \
        -of default=noprint_wrappers=1:nokey=1 ${1?path of the video}
}

# runner/slurm
# pu/cuvid

input () {
    # setopt localoptions nowarncreateglobal
    typeset -g input_{width,height} input=${1?path to the input video}
    video_size $input |
        reads input_{width,height}
    encoder+=( -i $input )
}

output () {
    # setopt localoptions nowarncreateglobal
    output_template=${1?template for the path of output file}
}

is_downscale () (( input_height > height ))

is_upscale () {
    local tolerance=${1?a tolerance in decimal notation (aka .1 for 10%)}
    (( ( input_height > height ) &&
       ( input_height - height ) < ( input_height * tolerance )))
}

scale () {
    typeset -g width height output
    for it ($available_sizes) {
        width=${it:r} height=${it:e}
        output="$( eval echo $output_template )"

        is_downscale  ||
        is_upscale .1 ||
        continue

        [[ -f $output && $output -nt $input ]] || {
            scaling_args
            encoder+=( $output )
        }
    }
}

encode () { $encoder }

#template=${1?the template for output file}
:        ${1?at least one video to encode}


for doit {
    input $doit
    # ffprobe_dump_in out/info $input
    output '${input:t:r}_${width}x${height}.${input:e}'
    scale always 240 downscale  upscale_almost '10%'
    encode
}
